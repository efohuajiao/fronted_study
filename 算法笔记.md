# 338.比特位计数

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

**示例 1：**

```
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
```

**示例 2：**

```
输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

### 使用Brian Kernighan （比特计算）算法

使用***x = x&(x-1*)**可以将x的二进制数减少一个1，使用循环**将计数变量递增**计算1的个数即可。

解题

```js
var countBits = function(n) {
    let arr = Array(n+1);
    for(let i = 0;i <= n;i++){
        arr[i] = counts(i);
    }
    return arr;
};
function counts(i){
    let count = 0;
    while(i>0){
        i = i & (i-1);
        count++;
    }
    return count;
}
```

---

# 448.找到所有数组中消失的数字

给你一个含 `n` 个整数的数组 `nums` ，其中 `nums[i]` 在区间 `[1, n]` 内。请你找出所有在 `[1, n]` 范围内但没有出现在 `nums` 中的数字，并以数组的形式返回结果。

**示例 1：**

```
输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
```

**示例 2：**

```
输入：nums = [1,1]
输出：[2]
```

思路：我的思路是使用includes从1到n(数组长度)进行判断，如果不包含，则直接数字i存入新数组

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findDisappearedNumbers = function(nums) {
    const n = nums.length;
    const newNums = [];
    for(let i = 1;i <= n;i++){
        if(!nums.includes(i)){
            newNums.push(i);
        }
    }
    return newNums;
};
```

官方题解：遍历数组，使用**范围之外的数字**来表示存在在数组nums中的数字。

```js
var findDisappearedNumbers = function(nums) {
    const n = nums.length;
    for (const num of nums) {
        const x = (num - 1) % n; //这里的n-1代表在序列数组中num本来应该所在的序号，因为num的范围是从1开始的。%n是为了避免碰到重复的数字，num已经加过n了。这样到最后，只有没有出现的数字所在的序号不会被加n。
        nums[x] += n;
    }
    const ret = [];
    //nums.entries()是生成nums的键值队，[0,]
    for (const [i, num] of nums.entries()) {
        if (num <= n) {
            ret.push(i + 1);
        }
    }
    return ret;
};

链接：https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/solutions/601946/zhao-dao-suo-you-shu-zu-zhong-xiao-shi-d-mabl/

```

```
例 
for (const num of nums) {
    const x = (num - 1) % n;
    nums[x] += n;
}
	原数组 4,3,2,7,8,2,3,1     			
第一次交换  num = 4 	x=3	4,3,2,15,8,2,3,1      		
第二次交换  num = 3	x=2	4,3,10,15,8,2,3,1     		
第三次交换  num = 10 x=1	4,11,10,15,8,2,3,1   		
第四次交换  num = 15	x=6	4,11,10,15,8,2,11,1          
第五次交换  num = 8	x=7	12,11,10,15,8,2,11,9 		
第六次交换  num = 2	x=1	12,19,10,15,8,2,11,9 		
第七次交换  num = 11	x=2	12,19,18,15,8,2,11,9
第八次交换  num = 10 x=1 12,27,18,15,8,2,11,9
由此可见，8和2没有变化，即它们所在的序列加一就是没有出现的数字
```

---

# 461.汉明距离

两个整数之间的 [汉明距离](https://baike.baidu.com/item/汉明距离) 指的是这两个数字对应二进制位不同的位置的数目。

给你两个整数 `x` 和 `y`，计算并返回它们之间的汉明距离。

 

**示例 1：**

```
输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
```

**示例 2：**

```
输入：x = 3, y = 1
输出：1
```

 我的解法

使用blob函数分别将x，y转换成二进制，并将它传给数组返回。然后对它们for循环进行比较。

```JS
var hammingDistance = function(x, y) {
    let X = blob(x);
    let Y = blob(y);
    let i = 0,j = 0;//j计算x和y二进制位数不同的个数
    let length = X.length >= Y.length ? X.length : Y.length;
    for(;i < length;i++){
        if(X[i]!=Y[i])
            j++;
    }
    return j;
};
function blob(x){
    let arr = new Array(32);
    arr.fill(0);
    let i = 0,j=0;
    while(x){
        i = x % 2;
        arr[j++] = i;
        x = parseInt(x/2);//js的Number不分整型和浮点型，所以要使用parseInt将/2的结果转为整型。
    }
    return arr;
}
```

官方

- **移位实现位计数**

​		将x和y进行异或，**相同为0，不同为1**，这样异或的结果s中为1的便是x和y二进制中不同的地方。然后让最低位和1进行与运算，相同则加一，不同加0，随后让s右移一位，再进行与运算。

```js
var hammingDistance = function(x, y) {
 	let s = x ^ y;
    let count = 0,i;
    while(s>0){
        i = s & 1;
        count+=i;
        s = s>>1;
    }
}
```

- **Brian Kernighan （比特计算）算法**

​	s = x ^ y。x和y异或后，所得的s为一个**包含1和0的二进制数**，如10001101，这样需要循环8次才能获得结果，可以使用**Brian Kernighan （比特计算）算法**计算s中1的个数，即使用**x&(x-1)**，每运行一次，s中的1就会减少1个。该算法会**删去s中最右侧的1**，最终循环的次数即为s二进制表示中1的数量。

```js
var hammingDistance = function(x, y) {
	s = x ^ y;
    for(let i = 0;s > 0;i++){
        s = s & (s-1);
    }
    return i;
}
```

# 78.子集

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```



# 20.有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

 

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```
输入：s = "(]"
输出：false
```

题解：使用栈进行解决，将右括号存储在数组中，然后将字符串一一入栈，如果是左括号则入栈，如果是右括号进行判断，如果跟出栈的符号能对应，则继续循环，否则return false。到最后，如果栈为空，则return true。

```js
var isValid = function(s) {
    let stack = [];//栈
    s = s.split("");//将字符串分割成数组
    let right = [')','}',']'];//将右阔靠存在right数组中
    for(let i = 0;i < s.length;i++){
        if(!right.includes(s[i])){//如果不是右括号则推入栈中
            stack.push(s[i]);
        }else{//不是则进行判断
            switch(s[i]){//跟栈顶出栈的元素进行比较，如果能匹配上，则继续循环，不能就return false
                case ")":
                    if(stack.pop()!='(')
                        return false;
                    break;
                case "}":
                    if(stack.pop()!='{')
                        return false;
                    break;
                case "]":
                    if(stack.pop()!='[')
                        return false;
                    break;
            }
        }

    }
    if(stack.length==0){//最后判断栈的长度，为0则说明全是有效括号，return true
        return true;
    }else{
        return false;//否则，return false
    }
};
```

# 169.多数元素

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1：**

```
输入：nums = [3,2,3]
输出：3
```

**示例 2：**

```
输入：nums = [2,2,1,1,1,2,2]
输出：2
```

## 暴力解法 

我的解法：暴力解法，**利用set去重**获取nums中的唯一值赋给新数组newNums。然后在**深拷贝**一个新的数组newNum。循环nums，如果nums中的值等于newNum中的值，则newNums加上自己。循环完后再循环newNums，如果它减去newNum中的对应的值再除去newNum对应的值大于n/2的话则返回。

```js
var majorityElement = function(nums) {
    let time = nums.length / 2;
    let newNums = [...new Set(nums)];//去重，获得新数组
    let newNum = JSON.parse(JSON.stringify(newNums));//深拷贝一个新数组
    for(let i = 0;i < nums.length;i++){
        for(let j = 0;j < newNums.length;j++){
            if(nums[i]==newNum[j])//如果值相等
                newNums[j]+=newNum[j];//newNums加上自身
        }
    }
    for(let i = 0;i < newNums.length;i++){
        if((newNums[i]-newNum[i])/newNum[i]>time){//如果减去自身除以自身大于time则返回
            return newNum[i];
        }
    }
};
```

## 哈希表

用哈希表统计数组元素中每个元素出现的次数，返回所有统计次数超过n/2的元素。元素作为哈希表的键，出现的次数作为哈希表的值。

```js
var majorityElement = function(nums) {
    let map = new Map();//创建哈希表
    let time = nums.length/2;
    for(let i = 0;i < nums.length;i++){
        if(map.has(nums[i])){//如果map有nums[i],则让次数加一
            map.set(nums[i],map.get(nums[i])+1);
        }else{//如果没有，则添加
            map.set(nums[i],1);
        }
    }
    for(let key of map.keys()){//使用for ... of遍历map的key
        if(map.get(key)>time){//如果key对应的值大于time则返回
            return key;
        }
    }
};
```



## Boyer-Moore 投票算法

记录第一个士兵为winner=nums[i]，然后设置count计数器为0。遍历循环数组，当与winner相同时，count++，不相同，count--，当count为0时，nums[i]重新赋值给winner。这样遍历结束后，winner就是所求的数。

```js
var majorityElement = function(nums) {
    let winner = nums[0];//创建士兵
    let count = 0;//创建计数器
    for(let i = 0;i < nums.length;i++){
        if(winner == nums[i]){//当nums[i]与士兵相同时count++
            count++;
        }else if(count == 0){//减到后面count为0时，winner重新赋值
            winner = nums[i];
            count++;
        }else{//不同时,count--
            count--;
        }
    }
    return winner;
};
```

“同归于尽消杀法” ：

由于多数超过50%, 比如100个数，那么多数至少51个，剩下少数是49个。

1. 遍历数组
2. 第一个到来的士兵，直接插上自己阵营的旗帜占领这块高地，此时领主 winner 就是这个阵营的人，现存兵力 count = 1。
3. 如果新来的士兵和前一个士兵是同一阵营，则集合起来占领高地，领主不变，winner 依然是当前这个士兵所属阵营，现存兵力 count 加一；
4. 如果新来到的士兵不是同一阵营，则前方阵营派一个士兵和它同归于尽。 此时前方阵营兵力-1, 即使双方都死光，这块高地的旗帜 winner 不变，没有可以去换上自己的新旗帜。
5. 当下一个士兵到来，发现前方阵营已经没有兵力，新士兵就成了领主，winner 变成这个士兵所属阵营的旗帜，现存兵力 count ++。
6. 就这样各路军阀一直厮杀以一敌一同归于尽的方式下去，直到少数阵营都死光，剩下几个必然属于多数阵营的，winner 是多数阵营。

（多数阵营 51个，少数阵营只有49个，死剩下的2个就是多数阵营的人）

# 229.多数元素||

## 暴力解法

```js
var majorityElement = function(nums) {
    let time = nums.length / 3;
    let Element = [];
    let newNums = [...new Set(nums)];
    let newNum = JSON.parse(JSON.stringify(newNums));
    for(let i = 0;i < nums.length;i++){
        for(let j = 0;j < newNums.length;j++){
            if(nums[i]==newNum[j] && nums[i]!=0)
                newNums[j]+=newNum[j];
            else if(nums[i]==newNum[j] && nums[i]==0){
                newNums[j]+=1;
            }
        }
    }

        for(let i = 0;i < newNums.length;i++){
            if(newNum[i] == 0){
                formula = (newNums[i]-newNum[i])/1;
            }else{
                formula = (newNums[i]-newNum[i])/newNum[i];
            }
            if(formula>time){
                Element.push(newNum[i]);
            }
        }
    
    
    return Element;
};
```



## 哈希表

用哈希表统计数组元素中每个元素出现的次数，返回所有统计次数超过n/3的元素。元素作为哈希表的键，出现的次数作为哈希表的值。

```js
var majorityElement = function(nums) {
    let time = nums.length / 3;//获取出现次数
    let Element = [];
    let map = new Map();//创建map字典，map键值一一对应
    for(let i = 0;i < nums.length;i++){
        if(map.has(nums[i])){//如果map有nums[i],则让次数加一
            map.set(nums[i],map.get(nums[i])+1);
        }else{//如果没有，则添加
            map.set(nums[i],1);
        }
    }
    for(let o of map.keys()){//使用for ... of遍历map的key
        if(map.get(o)>time){//如果key对应的值大于time则将其加入数组
            Element.push(o);
        }
    }
    return Element;
};
```

# 136.只出现一次的数字

给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

**示例 1 ：**

```
输入：nums = [2,2,1]
输出：1
```

**示例 2 ：**

```
输入：nums = [4,1,2,1,2]
输出：4
```

**示例 3 ：**

```
输入：nums = [1]
输出：1
```

## 异或

题目要求只是用常量额外空间，所以不能使用哈希表，使用哈希表则空间复杂度为O(n)，可以使用异或运算。

​	异或运算两数相同为0，不同为1。拓展开来，两个不同的数相异或，得到另一个数，当第二次遇到其中一个数时则会还原成另一个数。这用到了异或的交换律和结合律。*a*⊕*b*⊕*a*=*b*⊕*a*⊕*a*=*b*⊕(*a*⊕*a*)=*b*⊕0=*b*。



![img](https://assets.leetcode-cn.com/solution-static/136/3.PNG)

```js
var singleNumber = function(nums) {
    let single = nums[0];//先获取第一个数
    for(let i = 1;i < nums.length;i++){//i从1开始遍历
        single ^= nums[i];//不断与所有数进行异或，相同为0不同为1，剩到最后的数为只出现一次的数
    }
    return single;
};
```

## 哈希表（不考虑空间复杂度）

```js
var singleNumber = function(nums) {
    let map = new Map();
    for(let i = 0;i < nums.length;i++){
        if(map.has(nums[i])){
            map.set(nums[i],map.get(nums[i])+1);
        }else{
            map.set(nums[i],1);
        }
    }
    for(let key of map.keys()){
        if(map.get(key) == 1)
            return key;
    }
};
```

# 283.移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须**在不复制数组**的情况下原地对数组进行操作。

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

## 覆盖

创建一个count变量为0作为数组下标，for ...of遍历数组，当数组的值不为0的时候，将当前数组的值赋给以count作为下标的数组，令count++进入下一次循环。随后count的值一定为数组不为0的数字的长度。for循环nums.length-count次，给数组末尾补0。

```js
var moveZeroes = function(nums) {
    let count = 0;
    for(let i of nums){//for...of中的i是数组的value值
        if(i != 0){//此方法是索引从0开始，让数组的不为0的值覆盖为0的值
            nums[count++] = i;
        }
    }
    for(;count<nums.length;count++){
        nums[count] = 0;//想数组末尾补0
    }
};
```

## 我的解法

两层循环遍历，当遍历的值为0时，让当前值与后面的值进行交换。

```js
var moveZeroes = function(nums) {
    let count = 0;
    for(let i of nums){
        if(i != 0){
            nums[count++] = i;
        }
    }
    for(;count<nums.length;count++){
        nums[count] = 0;
    }
};
```

# 48.旋转图像

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)

```
输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

```js
var rotate = function(matrix) {
    let n = matrix.length;
    for (let i = 0; i < Math.floor(n / 2); ++i) {
        for (let j = 0; j < Math.floor((n + 1) / 2); ++j) {
            const temp = matrix[i][j];
            matrix[i][j] = matrix[n - j - 1][i];
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
            matrix[j][n - i - 1] = temp;
        }
    }

};
```

# 206.反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

```
输入：head = [1,2]
输出：[2,1]
```

**示例 3：**

```
输入：head = []
输出：[]
```

## 迭代

假设链表为 1→2→3→∅1，我们想要把它改成 ∅←1←2←3.

在遍历链表时，将当前节点的 next\textit{next}next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。

```ts
function reverseList(head: ListNode | null): ListNode | null {
    let prev = null;
    let curr = head;
    while(curr){
        const next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    return prev;    
};
```

# 回文链表

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)

```
输入：head = [1,2,2,1]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg)

```
输入：head = [1,2]
输出：false
```

## 数组双指针

将链表的值从头节点开始一一存进数组，然后用双指针从头和末尾去遍历数组进行比对。

```ts
function isPalindrome(head: ListNode | null): boolean {
    let arr:Array<number> = [];
    while(head){
        arr.push(head.val);
        head = head.next;
    }
    for(let i = 0,j = arr.length-1;i<arr.length,j>0;i++,j--){
        if(arr[i] != arr[j])
            return false;
    }
    return true;
};
```

## 递归

将head用全局变量指针存储，然后创建递归函数，**递归会为每一次递归的值创建一个执行上下文栈保留当前状态**，当递归到链表的最后会从后往前回退，然后利用这个特性跟全局变量指针进行对比，每一次都让指针指向下一个节点。

```tsx
let frontPointer ;
function recursivelyCheck (current:ListNode | null):boolean{
    if(current){//判断当前节点是否为空
        if(!recursivelyCheck(current.next)) return false;//递归会一直执行下去，并将变量当前状态存储在执行上下文栈中，直到链表的末尾后函数返回true,!true不执行所以执行下面的语句。
        if(frontPointer.val != current.val) return false;//将全局指针保存的值跟栈返回的状态的值进行对比，如果不同，则会返回false，上一条if语句就会执行，一直返回fals直到执行上下文栈为空
        frontPointer = frontPointer.next;
    }
    return true;

}
function isPalindrome(head: ListNode | null): boolean {
    frontPointer = head;//将头节点用全局变量存储
    return recursivelyCheck(head);
};
```

## 快慢指针

1. 找到前半部分链表的尾节点。
2. 反转后半部分链表。
3. 判断是否回文。
4. 恢复链表。
5. 返回结果。

使用**快慢指针**在一次遍历中找到：**慢指针一次走一步，快指针一次走两步**，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。

```ts
 const reverseList = (head) => {
    let prev = null;
    let curr = head;
    while (curr !== null) {
        let nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}
function endOfFirstHalf  (head:ListNode | null):ListNode{
    let fast = head;
    let slow = head;
    while(fast.next != null && fast.next.next != null){
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
function isPalindrome(head: ListNode | null): boolean {
    let left = head;
    let afterHalf = endOfFirstHalf(head);
    let reverAfter = reverseList(afterHalf);
    while(reverAfter!=null && left!=null){
        if(left.val !== reverAfter.val)
            return false;
        left = left.next;
        reverAfter = reverAfter.next;
    }
    return true;
};
```

# 合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```
输入：l1 = [], l2 = [0]
输出：[0]
```

 **提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

## 迭代

首先，我们设定一个哨兵节点 `prehead` ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 `prev `指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：**如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作**。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。

在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可

```ts
function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {
    const Link = new ListNode(-1);
    let prev = Link;
    while(list1!== null && list2!=null){
        if(list1.val <= list2.val){
            prev.next = list1;
            list1 = list1.next;
        }else{
            prev.next = list2;
            list2 = list2.next;
        }
        prev = prev.next;
    }
    prev.next = list1 === null ? list2 : list1;
    return Link.next;
};
```

# 141.环形链表

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

 

**提示：**

- 链表中节点的数目范围是 `[0, 104]`
- `-105 <= Node.val <= 105`
- `pos` 为 `-1` 或者链表中的一个 **有效索引** 。

## 哈希

遍历链表，将链表的每一个节点存入哈希表，最开始判断哈希表中是否有该节点，有的话说明是循环链表，直接返回true。如果循环完哈希表中的值都为1，说明不是循环链表，返回false。

```ts

function hasCycle(head: ListNode | null): boolean {
    let map = new Map();
    while(head){
        if(map.get(head)){//先判断哈希表中是否含有该节点，有的话说明是循环链表返回true
            return true;
        }else{
            map.set(head,1);//没有该节点往哈希表中添加该节点
        }
        head = head.next;
    }   
    return false;//循环结束，直到最后都没有返回true说明不是循环链表，返回false
};
```

## 快慢指针

「Floyd 判圈算法」（又称龟兔赛跑算法），假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。

我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一慢。**慢指针每次只移动一步，而快指针每次移动两步**。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

### 细节

将fast设置为head.next，将slow设置为head是为了能进入while循环，因为循环条件是**slow!=fast**，如果他们相等，则无法进入循环。

```ts
function hasCycle(head: ListNode | null): boolean {
    if(head === null || head.next === null)
        return false;
    let fast = head.next;
    let slow = head;
    while(slow != fast){
        if(fast === null || fast.next === null)
            return false;
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;
};
```

# 142.环形链表Ⅱ

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。



 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

 

**提示：**

- 链表中节点的数目范围在范围 `[0, 104]` 内
- `-105 <= Node.val <= 105`
- `pos` 的值为 `-1` 或者链表中的一个有效索引

 

**进阶：**你是否可以使用 `O(1)` 空间解决此题？

## 集合

因为set集合不允许重复，所以遍历链表，将每一个节点存入集合，当集合中存在节点说明是循环链表，返回。如果不是，则while循环结束，返回null。

```ts
function detectCycle(head: ListNode | null): ListNode | null {
    let set = new Set();
    while(head){
        if(set.has(head)){
            return head;
        }else{
            set.add(head);
        }
        head = head.next;
    }
    return null;
};
```

## 快慢指针

```ts
function detectCycle(head: ListNode | null): ListNode | null {
    if (head === null) {
        return null;
    }
    let slow = head, fast = head;
    while (fast !== null) {
        slow = slow.next;
        if (fast.next !== null) {
            fast = fast.next.next;
        } else {
            return null;
        }
        if (fast === slow) {
            let ptr = head;
            while (ptr !== slow) {
                ptr = ptr.next;
                slow = slow.next;
            }
            return ptr;
        }
    }
    return null;

};
```





# 160.相交链表

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**自定义评测：**

**评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：

- `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`
- `listA` - 第一个链表
- `listB` - 第二个链表
- `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数
- `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。

 

**示例 1：**

[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
```

 

**示例 2：**

[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)

```
输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```

 

**提示：**

- `listA` 中节点数目为 `m`
- `listB` 中节点数目为 `n`
- `1 <= m, n <= 3 * 104`
- `1 <= Node.val <= 105`
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA] == listB[skipB]`

## 哈希集合

set集合不允许有重复的值，所以可以先将headA的所有节点存入set集合，然后再循环headB判断，如果有相同的说明他们是相交的起始节点。

```ts
function getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {
    let set = new Set();
    while(headA != null){
        set.add(headA);
        headA = headA.next;
    }
    while(headB != null){
        if(set.has(headB)){
            return headB;
        }
        headB = headB.next;
    }
    return null;
};
```

## 双指针

使用双指针的方法，可以将空间复杂度降至 O(1))。

只有当链表 headA 和 headB 都不为空时，两个链表才可能相交。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。

当链表 headA 和 headB 都不为空时，创建两个指针 pA和 pB，初始时分别指向两个链表的头节点 headA和 headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：

每步操作需要同时更新指针 pA 和 pB。

如果指针 pA 不为空，则将指针 pA移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。

如果指针 pA为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。

当指针 pA和 pB指向同一个节点或者都为空时，返回它们指向的节点或者 null。

```ts
function getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {
    if(headA === null || headB === null)
        return null;
    let PA = headA,PB = headB;
    while(PA != PB){
        PA = PA ===null ? headB : PA.next;
        PB = PB ===null ? headA : PB.next;
    }
    return PA;
};
```






# 101.对称二叉树

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

子树堆成条件：

1. **它们两个根节点具有相同的值** 
2. **每个树的右子树都与另一个树的左子树镜像对称**    

## 递归

如果一个树的左子树与右子树镜像对称，那么这个树是对称的。

通过递归判断，第一次将树的根传两次进去，然后第二次传根的left和right进行判断，第三次传根left的left和根right的right以及根left的right和根right的left进行比较....以此类推，直到到树的底层为止

```ts
class TreeNode {
    val: number
    left: TreeNode | null
    right: TreeNode | null
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = (val===undefined ? 0 : val)
        this.left = (left===undefined ? null : left)
        this.right = (right===undefined ? null : right)
    }
}
//递归判断二叉树是否对称
const check = (p:TreeNode|null,q:TreeNode|null):boolean=>{
    if(!p && !q) return true;//判断两个节点是否同时不存在，不存在返回true
    if(!p || !q) return false;//如果只有一个不存在，说明不对称，返回false
    return p.val === q.val && check(p.left,q.right) && check(p.right,q.left); //第一个条件是两个节点的值是否相等，第二个条件是将左节点的左儿子和右节点的右儿子进行比较，第三个条件是将左节点的右儿子和右节点的左儿子进行比较
}
function isSymmetric(root: TreeNode | null): boolean {
    return check(root,root);//首次传两个根节点
};
```

## 迭代

使用队列，创建一个队列，先推入两次根节点，随后进行循环（循环条件是队列的长度），两次取出队列的值进行判断，如果两个节点都为空说明这两个节点是对称的，设置为continue，如果两个节点有一个为空或者它们的val值不相等，则返回false。然后分别推入节点的左儿子和另一个节点的右儿子，以及节点的右儿子和另一个节点的左儿子，再次进入循环。循环结束，返回true。

```ts
const check = (u:TreeNode|null , v:TreeNode|null):boolean=>{
    const q:TreeNode[] = [];//创建队列
    q.push(u);//推入根节点两次，因为要分别判断根的left和right
    q.push(v);
    while(q.length){//进行循环
        u = q.shift();//取出队列的前两个值进行判断
        v = q.shift();

        if(!u && !v) continue;//如果它们都为空说明是对称的，结束本次循环进入下次循环
        if((!u || !v) || u.val != v.val) return false;//如果它们有一个为空，或者值不相等，返回false
		//推入u的left和v的right，u的right和v的left，因为它们镜像，要比对的是它们的值
        q.push(u.left);
        q.push(v.right);

        q.push(u.right);
        q.push(v.left);
    }
    return true;//循环结束，说明是对称的
}
function isSymmetric(root: TreeNode | null): boolean {
    return check(root,root);
};
```

# 617.合并二叉树

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)

```
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
```

**示例 2：**

```
输入：root1 = [1], root2 = [1,2]
输出：[2,2]
```

##  递归

1. root1为null，root2不为null，返回root2
2. root2为null，root1不为null，返回root1
3. 创建新的树，将root1和root2的val值进行相加，节点的left和right为root1和root2节点的left和right的val值相加（即进入递归）
4. 最后返回树

```ts
function mergeTrees(root1: TreeNode | null, root2: TreeNode | null): TreeNode | null {
    if(!root1) return root2;
    if(!root2) return root1;
    let t = new TreeNode(root1.val+root2.val);
    t.left = mergeTrees(root1.left,root2.left);
    t.right = mergeTrees(root1.right,root2.right);
    return t;
};
```

## 迭代



# 104.二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

## 递归

如果我们知道了左子树和右子树的最大深度 lll 和 rrr，那么该二叉树的最大深度即为

max⁡(l,r)+1 \max(l,r) + 1
max(l,r)+1
而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1)O(1)O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。

[104. 二叉树的最大深度 - 力扣（Leetcode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/solutions/349250/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/)

```ts
function maxDepth(root: TreeNode | null): number {
    if(!root) return 0;
    let left = maxDepth(root.left)+1;
    let right = maxDepth(root.right)+1;
    let max = left>right?left:right;
    return max;
};
```

# 226.反转二叉树

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```

## 递归

采用先序遍历，先判断当前二叉树是否是null，是的话就返回null，遍历交换当前节点的左右节点，然后再递归，将左右节点分别传入函数，最后返回root二叉树。

```ts
function invertTree(root: TreeNode | null): TreeNode | null {
    if(!root) return null;
    let left  = root.left;//用变量获取左右节点
    let right = root.right;
    root.left = right;//交换左右节点
    root.right = left;
    invertTree(root.left);//将左右节点传入函数进行递归交换
    invertTree(root.right);
    return root;
};
```

## 迭代

采用栈存储当前节点，循环条件是栈的长度不为0。然后定义变量存储出栈的值，判断变量是否为null，是的话跳过本次循环，不是则交换左右节点。将左右节点再推入栈中,直到栈为空。

```ts
function invertTree(root: TreeNode | null): TreeNode | null {
    let stack = [];
    stack.push(root);//将根节点存储栈中
    while(stack.length>0){
        let t = stack.pop();//出栈
        if(t == null) continue;//如果t为空，则跳过本次循环，不交换
        let left = t.left;//分别用变量存储左右节点
        let right = t.right;
        t.left = right;//将t的左右节点进行交换
        t.right = left;
        stack.push(t.left);//将交换后的左右节点再推入栈中，进入循环
        stack.push(t.right);
    }
    return root;
};
```

# 94.二叉树的中序遍历

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

##  递归

中序遍历，左子树——根节点——右子树，访问左子树和右子树的时候同样可以以这种方式遍历。

```ts
function inorderTraversal(root: TreeNode | null): number[] {
    let t:number[] = [];
    //递归遍历函数
    const inorder = (root:TreeNode)=>{
        if(!root)//递归结束条件,节点为空，返回
            return;
        inorder(root.left);//先遍历左节点,所有的状态暂存栈中
        t.push(root.val);//左节点为空后,一一将值推入数组
        inorder(root.right);//遍历右节点
    }
    inorder(root);
    return t;
};
```

## 迭代

先一次性将树的左子树的左节点全都推入栈中，随后取出栈顶元素，将其推入数组，然后将当前节点赋值为节点的右孩子，如果右孩子为空，但栈长度仍大于0，进入循环。

```ts
function inorderTraversal(root: TreeNode | null): number[] {
    let t1:TreeNode[] = [],t2:number[] = [];
    while(t1.length > 0 || root){//循环条件：数组的长度大于0或者root不为null
        while(root){//先把树的左子树的左节点全都推入栈
            t1.push(root);
            root = root.left;
        }
        root = t1.pop();//栈顶元素出栈
        t2.push(root.val);//将值推入数组
        root = root.right;//root赋值为它的右孩子，若右孩子不为空，则会在下一次循环推入栈中，为空，则会跳过root循环，下一个栈顶元素出栈
    }
    return t2;
};
```

# 98.验证二叉搜索树

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

```
输入：root = [2,1,3]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

 

**提示：**

- 树中节点数目范围在`[1, 104]` 内
- `-231 <= Node.val <= 231 - 1`

## 递归

设置递归函数，传递三个参数，判断的节点，节点的下界，节点的上界，然后依次递归，如果只单纯比较把节点的左节点和右节点和节点进行比较，那么会出现左右子树中存在值比当前节点小或大的情况，所以**比较的同时要把当前节点的上下界一起传递**。

```ts
function isValidBST(root: TreeNode | null): boolean {
    const isTrue = (root: TreeNode | null,up,lower):boolean => {
        if(!root) return true;
        if(root.val >= up || root.val <= lower)   return false;//如果当前节点大于等于上届，或者小于等于下界，说明不在范围区间内，返回false
        return isTrue(root.left,root.val,lower) && isTrue(root.right,up,root.val);//左节点要比当前节点要小，所以上界传当前节点值，下界为Infinity，右节点要比当前节点大，所以下界传当前节点的值，上界为Infinity
    }
    return isTrue(root,Infinity,-Infinity);
};
```

## 迭代

将节点的所有左节点推入栈，然后出栈顶元素，将栈顶元素的值和定义的最小值比较，如果小的话说明不是二叉搜索树，返回false，大则将节点的值赋给最小值，节点的右节点赋给root。在循环结束后，说明遍历完，返回true。

```ts
function isValidBST(root: TreeNode | null): boolean {
    let stack = [];
    let inorder = -Infinity;
    while(stack.length > 0 || root){
        while(root){
            stack.push(root);
            root = root.left;//将节点的所有左节点入栈
        }
        root = stack.pop();//出栈顶元素，即最左边的元素
        if(root.val <= inorder) return false;//如果节点的值比定义的最小值小，说明不符合条件按
        inorder = root.val;//大的话进行赋值，进入下次循环
        root = root.right;//节点赋值为右节点
    }
    return true;
};
```

# 102.二叉树的层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

 

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`

# 迭代

将节点存入队列，遵循先进先出的原则进行层序遍历。因为需要把每一层的节点单独存为一个数组，所以在循环的时候获取队列的长度，一次性处理一层的数据。

```js
var levelOrder = function(root) {
    const queue = [];
    const result = [];
    if (!root) {//如果节点为空，直接返回空队列
        return result;
    }
    queue.push(root);//将节点入队
    while(queue.length !=  0){
        let n = queue.length;//获取当前节点的长度，也就是这一层的节点个数
        let q = [];//存放这一层的节点的数组
        for(let i = 0;i < n;i++){
            const node = queue.shift(); //出队           
            q.push(node.val);//将节点的值推入数组
            if (node.left) queue.push(node.left);//如果节点有左节点，将它推入数组
            if (node.right) queue.push(node.right);//如果节点有右节点，将它推入数组
        }
        result.push(q);//将这一层的节点值的数组推入节点数组中
    }
    return result;
};
```

# 子集

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

 

**提示：**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有元素 **互不相同**

## 递归

使用回溯算法进行解题。

```ts
function subsets(nums: number[]): number[][] {
    let path = [];//每一种可能的结果
    let result = [];//最终结果
    const backTracking = (startIndex)=>{
        result.push([...path]);
        if(startIndex >= nums.length)//递归终止条件
            return;
        for(let i = startIndex;i < nums.length;i++){
            path.push(nums[i]);//将nums中的值推入数组
            backTracking(i+1);//令i+1进入递归
            path.pop();//撤销结果
        }
    }
    backTracking(0);//传入索引最小的值0进入递归
    return result;
};
```

[78. 子集 - 力扣（Leetcode）](https://leetcode.cn/problems/subsets/solutions/850474/dai-ma-sui-xiang-lu-78-zi-ji-hui-su-sou-6yfk6/)

# 543.二叉树的直径

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

 

**示例 :**
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

 

**注意：**两结点之间的路径长度是以它们之间边的数目表示。

## 递归

假定p是树T中的一个节点，那么p的深度就是节点p的祖先的个数，不包括p本身。这**等价于p到根节点有多少条边**。这种定义表明，树的根节点的深度为0.

```js
var diameterOfBinaryTree = function(root) {
    let ans = 0;
    const depth = (root)=>{
        if(!root) return 0;
        let L = depth(root.left);
        let R = depth(root.right);
        ans = Math.max(ans,L+R+1);
        return Math.max(L,R)+1;//当前节点较于父节点的深度
    }
    depth(root);
    return ans - 1;
};
```

# 75.颜色分类

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。



必须在不使用库内置的 sort 函数的情况下解决这个问题。

 

**示例 1：**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**示例 2：**

```
输入：nums = [2,0,1]
输出：[0,1,2]
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` 为 `0`、`1` 或 `2`

 

**进阶：**

- 你能想出一个仅使用常数空间的一趟扫描算法吗？

## 单指针

```js
var sortColors = function(nums) {
    let len = nums.length;
    let ptr = 0;
    for(let i = 0;i < len;i++){
        if(nums[i] == 0){
            let temp = nums[i];
            nums[i] = nums[ptr];
            nums[ptr] = temp;
            ptr++;
        }
    }
    for(let i = 0;i < len;i++){
        if(nums[i] == 1){
            let temp = nums[i];
            nums[i] = nums[ptr];
            nums[ptr] = temp;
            ptr++;
        }
    }
};
```

# 155.最小栈

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

 

**示例 1:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

 

**提示：**

- `-231 <= val <= 231 - 1`
- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用
- `push`, `pop`, `top`, and `getMin`最多被调用 `3 * 104` 次

## 辅助栈

初始化的时候定义一个栈和辅助栈，初始存放Infinity，然后入栈时，普通栈正常入栈，辅助栈则是存放辅助栈栈顶和入栈元素中较小的那个值。出栈的时候，普通栈和辅助栈一起出栈，这样普通栈对应的对小值，在辅助栈中都有体现。

```js
var MinStack = function() {
    this.data = [];
    this.minData = [Infinity];//定义辅助栈，初始存放Infinity
};

/** 
 * @param {number} val
 * @return {void}
 */
MinStack.prototype.push = function(val) {
    this.data.push(val);
    this.minData.push(Math.min(this.minData[this.minData.length-1],val));//辅助栈存放辅助栈栈顶和入栈元素中较小的一个
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    this.data.pop();
    this.minData.pop();//两个栈一起出栈
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.data[this.data.length-1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
    return this.minData[this.minData.length-1];
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(val)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
```

# 114.二叉树展开为链表

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [0]
输出：[0]
```

 

**提示：**

- 树中结点数在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

 

**进阶：**你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？

## 找左子树的最右节点

找root左子树的最右节点，将最右节点的right赋值为root的right，随后将最右节点的前驱节点赋给root的右节点，然后依次循环.

```js
var flatten = function(root) {
    let curr = root;//将root节点赋给curr
    while(curr != null){//循环条件curr不为空
        if(curr.left != null){//如果curr有左节点
            const next = curr.left;
            let predecessor = next;
            while(predecessor.right != null){
                predecessor = predecessor.right;//寻找curr左节点的最右节点
            }
            predecessor.right = curr.right;//将最右节点的右节点赋值为当前节点的右节点
            curr.left = null;//将当前节点的左节点赋null
            curr.right = next;//当前节点的右节点为当前节点的左节点
        }
        curr = curr.right;//将当前节点赋值为当前节点的右节点，依次循环下去
    }
};
```

[114. 二叉树展开为链表 - 力扣（Leetcode）](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solutions/356853/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/)

## 前序遍历

先前序遍历树，将其每一个节点存入list顺序表。然后for循环，将root的每一个节点赋值为下一个节点。

```js
var flatten = function(root) {
   let list = [];
   const preorder = (root,list)=>{
       if(root){
           list.push(root);
           preorder(root.left,list);
           preorder(root.right,list);
       }
   }
   preorder(root,list);
   for(let i = 1;i < list.length;i++){
       let prev = list[i - 1];//第一次prev为root
       let next = list[i];//next为左子树的第一个节点
       prev.left = null;//将左节点赋值为空
       prev.right = next; //右节点赋值为next
   }
};
```

# 121.买卖股票的最佳时机

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

 

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

 

**提示：**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 104`

## 动态规划

```js
var maxProfit = function(prices) {
        let minpice = Infinity;//设置最小值
        let maxprofit = 0;
        for (let i = 0; i < prices.length; i++) {
            if(prices[i] < minprofit){//比较最小值
                minprofit = prices[i];
            }else if(prices[i] - minpice > maxprofit){//当前天数减去最小金额则最大利润转换
                maxprofit = prices[i] - minpice;
            }
        }
        return maxprofit;

};
```

# 22.括号生成

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

 

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```

 

**提示：**

- `1 <= n <= 8`

## 回溯

```js
var generateParenthesis = function(n) {

    const result = [];//结果集

    const dfs = (str,open,close) => {//三个参数分别是括号组合，(的数量、)的数量
        if(close > open || open > n)    return;//如果)的数量大于(或)的数量大于n，则说明不是有效的括号组合，返回
        if(str.length === 2 * n){//如果str的长度等于2倍的n，则说明括号有效，将其推入结果集
             result.push(str)
             return;
        }  ;
        dfs(str+"(",open+1,close);//递归左括号
        dfs(str+")",open,close+1);//递归右括号
    }
    dfs("",0,0);//初始str为空，open和close都为0
    return result;
};
```

